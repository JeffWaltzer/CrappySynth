<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        function playSynth(note) {
            const frequencies = {
                A: 220.0,  // Frequency for A
                B: 246.94, // Frequency for B
                C: 261.63  // Frequency for C
            };
            const frequency = frequencies[note] || 220.0; // Fallback to A if note is invalid
            const selectedInstrument = document.getElementById("instrument").value;
            if (selectedInstrument === "flute") {
                fluteSound(audioContext, frequency, 2); // Play flute for 2 seconds
            } else if (selectedInstrument === "tubularBell") {
                tubularBellSound(audioContext, frequency, 2); // Play tubular bell for 2 seconds
            } else if (selectedInstrument === "marimba") {
                marimbaSound(audioContext, frequency, 2); // Play marimba for 2 seconds
            } else if (selectedInstrument === "guitar") {
                guitarSound(audioContext, frequency, 2); // Play guitar for 2 seconds
            }
        }

    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physical Modeling Synthesizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #282c34;
            color: white;
            text-align: center;
            margin: 0;
            padding: 20px;
        }

        h1 {
            margin-bottom: 30px;
        }

        button {
            padding: 15px 30px;
            margin: 10px;
            font-size: 18px;
            color: white;
            background-color: #61dafb;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background-color: #21a1f1;
        }
    </style>
</head>
<body>
<h1>Physical Modeling Synthesizer</h1>
<div>
    <label for="instrument">Select Instrument:</label>
    <select id="instrument">
        <option value="flute">Flute</option>
        <option value="tubularBell">Tubular Bell</option>
        <option value="guitar">Guitar</option>
        <option value="marimba">Marimba</option>
    </select>
</div>
<div>
    <button onclick="playSynth('A')">Play A</button>
    <button onclick="playSynth('B')">Play B</button>
    <button onclick="playSynth('C')">Play C</button>
    <button onclick="playEmChord()">Play E Minor Chord</button>
</div>
<script>
    // Initialize Audio Context
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Flute Sound Generation with Resonance and Sine Wave
    function fluteSound(ctx, frequency, duration) {
        const oscillator = ctx.createOscillator();
        oscillator.type = "sine"; // Sine wave for smooth flute sound
        oscillator.detune.value = -10; // Slight detune for organic texture
        oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);
        const bandpass = ctx.createBiquadFilter(); // Add resonance with bandpass filter
        bandpass.type = "bandpass";
        bandpass.frequency.setValueAtTime(frequency, ctx.currentTime);
        bandpass.Q.setValueAtTime(12, ctx.currentTime); // Set quality factor for resonance

        // Amplitude Envelope
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.8, ctx.currentTime + 0.1); // Attack
        gain.gain.exponentialRampToValueAtTime(0.7, ctx.currentTime + 0.4); // Decay
        gain.gain.setValueAtTime(0.6, ctx.currentTime + duration - 0.2); // Sustain
        gain.gain.linearRampToValueAtTime(0.0, ctx.currentTime + duration + 0.05); // Release

        oscillator.connect(bandpass); // Connect oscillator to bandpass filter
        bandpass.connect(gain); // Connect bandpass filter to gain
        gain.connect(ctx.destination);

        oscillator.start();
        oscillator.stop(ctx.currentTime + duration); // Stop after the specified duration
    }

    // Tubular Bell Sound Generation
    function tubularBellSound(ctx, frequency, duration) {
        const oscillator = ctx.createOscillator();
        const secondOscillator = ctx.createOscillator(); // Add a secondary oscillator for depth
        const thirdOscillator = ctx.createOscillator(); // Add a third oscillator for more resonance
        const detuneOscillator = ctx.createOscillator(); // Detuned oscillator for additional harmonics

        oscillator.type = "triangle"; // Use triangle wave for smoother tone
        oscillator.frequency.setValueAtTime(frequency * 0.9, ctx.currentTime); // Lower pitch for depth
        secondOscillator.type = "triangle";
        secondOscillator.frequency.setValueAtTime(frequency * 1.3, ctx.currentTime); // Moderate harmonic
        thirdOscillator.type = "sine"; // Use sine for richer resonance
        thirdOscillator.frequency.setValueAtTime(frequency * 1.8, ctx.currentTime); // Add a lower harmonic
        detuneOscillator.type = "triangle";
        detuneOscillator.frequency.setValueAtTime(frequency * 0.95, ctx.currentTime); // More subtle detuning

        oscillator.frequency.exponentialRampToValueAtTime(frequency * 0.88, ctx.currentTime + 0.8); // Larger drop for warmth
        thirdOscillator.frequency.exponentialRampToValueAtTime(frequency * 1.6, ctx.currentTime + 0.8); // Match ramp for mellow resonance
        detuneOscillator.frequency.exponentialRampToValueAtTime(frequency * 0.92, ctx.currentTime + 0.9); // Softer detuned ramp

        // Amplitude Envelope
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.7, ctx.currentTime + 0.2); // Softer attack
        gain.gain.exponentialRampToValueAtTime(0.3, ctx.currentTime + duration - 0.5); // Milder decay
        gain.gain.linearRampToValueAtTime(0.0, ctx.currentTime + duration + 0.2); // Slightly longer release

        oscillator.connect(gain);
        secondOscillator.connect(gain); // Connect secondary oscillator
        thirdOscillator.connect(gain); // Connect third oscillator
        detuneOscillator.connect(gain); // Connect detuned oscillator
        gain.connect(ctx.destination);

        oscillator.start();
        secondOscillator.start(); // Start second oscillator
        thirdOscillator.start(); // Start third oscillator
        detuneOscillator.start(); // Start detuned oscillator
        oscillator.stop(ctx.currentTime + duration); // Stop after specified duration
        secondOscillator.stop(ctx.currentTime + duration); // Stop second oscillator
        thirdOscillator.stop(ctx.currentTime + duration); // Stop third oscillator
        detuneOscillator.stop(ctx.currentTime + duration); // Stop detuned oscillator
    }


    // Function to Play a Note
    // Guitar Sound Generation
function playEmChord() {
    const eFrequency = 164.81; // E3
    const gFrequency = 196.00; // G3
    const bFrequency = 246.94; // B3
    const chordDuration = 2; // 2 seconds
    const selectedInstrument = document.getElementById("instrument").value;
    if (selectedInstrument === "flute") {
        fluteSound(audioContext, eFrequency, chordDuration);
        fluteSound(audioContext, gFrequency, chordDuration);
        fluteSound(audioContext, bFrequency, chordDuration);
    } else if (selectedInstrument === "tubularBell") {
        tubularBellSound(audioContext, eFrequency, chordDuration);
        tubularBellSound(audioContext, gFrequency, chordDuration);
        tubularBellSound(audioContext, bFrequency, chordDuration);
    } else if (selectedInstrument === "marimba") {
        marimbaSound(audioContext, eFrequency, chordDuration);
        marimbaSound(audioContext, gFrequency, chordDuration);
        marimbaSound(audioContext, bFrequency, chordDuration);
    } else if (selectedInstrument === "guitar") {
        guitarSound(audioContext, eFrequency, chordDuration);
        guitarSound(audioContext, gFrequency, chordDuration);
        guitarSound(audioContext, bFrequency, chordDuration);
    }
    }
function guitarSound(ctx, frequency, duration) {
    const oscillator = ctx.createOscillator();
    oscillator.type = "sawtooth"; // Sawtooth wave for more realistic harmonics
    oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);

    const detunedOscillator = ctx.createOscillator(); // Enhance with detuned harmonic oscillator
    detunedOscillator.type = "sawtooth";
    detunedOscillator.detune.setValueAtTime(-12, ctx.currentTime); // Detune for harmonic warmth
    detunedOscillator.frequency.setValueAtTime(frequency, ctx.currentTime);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0, ctx.currentTime);
    gain.gain.linearRampToValueAtTime(1.0, ctx.currentTime + 0.02); // Quick attack
    gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration); // Quick decay to mimic pluck

    // Body resonance effect for pluck
    const bodyFilter = ctx.createBiquadFilter();
    bodyFilter.type = "lowpass";
    bodyFilter.frequency.setValueAtTime(2200, ctx.currentTime); // High frequency for initial brightness
    bodyFilter.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + duration); // Frequency drop for realism

    // Physical resonance simulation
    const resonance = ctx.createConvolver();
    const impulse = ctx.createBuffer(2, ctx.sampleRate / 2, ctx.sampleRate); // Simulated impulse response
    const left = impulse.getChannelData(0);
    const right = impulse.getChannelData(1);
    for (let i = 0; i < left.length; i++) {
        left[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / left.length, 2); // Damped random signal
        right[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / right.length, 2); // Damped random signal
    }
    resonance.buffer = impulse;

    oscillator.connect(bodyFilter);
    detunedOscillator.connect(bodyFilter); // Connect detuned oscillator
    bodyFilter.connect(resonance);
    resonance.connect(gain);
    gain.connect(ctx.destination);

    oscillator.start();
    detunedOscillator.start(); // Start detuned oscillator
    oscillator.stop(ctx.currentTime + duration); // Stop after the specified duration
    detunedOscillator.stop(ctx.currentTime + duration); // Stop detuned oscillator
}

    function makeDistortionCurve(amount) {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100, curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; i++) {
            const x = (i * 2) / n_samples - 1;
            curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
        }
        return curve;
    }

    // Marimba Sound Generation
    function marimbaSound(ctx, frequency, duration) {
        const oscillator = ctx.createOscillator();
        oscillator.type = "square"; // Square wave for percussive tone
        oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);

        // Amplitude Envelope
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(1.2, ctx.currentTime + 0.02); // Quick attack for percussive sound
        gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration); // Rapid decay for short marimba notes

        // Filter for marimba tone shaping
        const bandpass = ctx.createBiquadFilter();
        bandpass.type = "bandpass";
        bandpass.frequency.setValueAtTime(frequency, ctx.currentTime);
        bandpass.Q.setValueAtTime(8, ctx.currentTime); // Moderate quality for defined tone

        oscillator.connect(bandpass);
        bandpass.connect(gain);
        gain.connect(ctx.destination);

        oscillator.start();
        oscillator.stop(ctx.currentTime + duration); // Stop after the specified duration
    }

</script>
</body>
</html>